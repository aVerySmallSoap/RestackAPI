import json

from modules.utils.load_configs import DEV_ENV


def analyze_results(session_name: str, wapiti_path:dict = None, zap_path:dict = None) -> dict:
    report_wap = wapiti_path
    report_zap = zap_path
    rules_wap = report_wap["runs"][0]["tool"]["driver"]["rules"]
    rules_zap = report_zap["runs"][0]["tool"]["driver"]["rules"]
    results_wap = report_wap["runs"][0]["results"]
    results_zap = report_zap["runs"][0]["results"]
    union_list: list = []
    intersection_list: list = []
    # combined results
    union_list.append(results_wap)
    union_list.append(results_zap)
    _wap_rules = map_rules(rules_wap)
    _zap_rules = map_rules(rules_zap)
    for zap_vuln in results_zap:
        # Compare each vulnerability in _ruled_zap to _ruled_wap.
        # If there is an overlap in Common Weakness Enumeration (CWE), then mark the vulnerability as highly likely present in the system.
        _zap_rule = _zap_rules.get(zap_vuln["ruleId"])
        for wap_vuln in results_wap:
            # Compare the zap vulnerability to the list of wapiti vulnerabilities and find one with a similar CWE
            _wap_rule = _wap_rules.get(wap_vuln["ruleId"])
            for tag in _wap_rule["properties"]["tags"]:
                if "CWE-" in tag:
                    # If they have the same CWE and are present in the same URI/endpoint, then we have a match.
                    if int(str.split(tag, "-")[1]) == int(_zap_rule["properties"]["cwe"]) and \
                            wap_vuln["locations"][0]["physicalLocation"]["artifactLocation"]["uri"] == \
                            zap_vuln["locations"][0]["physicalLocation"]["artifactLocation"]["uri"]:
                        # Increase the confidence of the vulnerability since wapiti and zap detected it
                        # TODO: implement confidence increase
                        intersection_list.append(zap_vuln)
    data = {"union": union_list, "intersection": intersection_list, "individual_results": [results_wap, results_zap],
         "rules": [_wap_rules, _zap_rules]}
    with open(f"{DEV_ENV['report_paths']['full_scan']}\\{session_name}.json", "w+") as writable:
        writable.write(json.dumps(data))
        writable.flush()
        writable.close()
    return data

def map_rules(rule_list:list[dict]) -> dict:
    """Maps the rules found in a SARIF file by making the id as the key and the extra properties as its value.
    The purpose of this is to make rule lookups much faster rather than looping through every rule each time.
    :param rule_list: List of rules found in a SARIF file.
    :return: Dictionary of rule id and extra properties as a dictionary.
    """
    _returnable = {}
    for rule_item in rule_list:
        _rule_id = ""
        _values = {}
        for key, value in rule_item.items():
            if key == "id":
                _rule_id = value
                continue
            _values[key] = value
        _returnable[_rule_id] = _values
    return _returnable