# TODO: Compare results from wapiti and zap using Exploitability, Severity, Confidence, and Business Criticality (optional).
# TODO: Based on research, a unified report is better for overall practicality, while a deduplicated report is better for precision
# note: Template or conversions can be ENUMS
import json
import urllib.parse
from modules.utils.load_configs import ZAP_MAPPING

# TODO: function does not error, provide safety and error checks
# TODO: test function performance
def find_matching():
    zap_report = json.load(open("../../temp/zap/zap_test.json"))
    wapiti_report = json.load(open("../../reports/wapiti_test.json"))

    # convert zap findings to wapiti equivalent
    converted = []
    residue = []
    for alert in zap_report: # loop is n + (n * 18) + n * 2 | 18 = length of template items | this is the worse-case
        if alert["risk"] == "Informational":
            continue
        is_residue = True
        for key,value in ZAP_MAPPING.items(): # A Hashmap or list of enums should perform faster?
            if type(value) == dict: #Clickjacking has two entries
                for entry in value.keys():
                    if alert["alert"] == entry:
                        alert["alert"] = key
                        converted.append(alert["alert"])
                        is_residue = False
                        break
            if alert["alert"] == value:
                alert["alert"] = key
                converted.append(alert["alert"])
                is_residue = False
        if is_residue:
            residue.append(alert["alert"])

    #TODO: check if the respective alerts found the vulnerability on the same path
    #might be redundant since the template already checks how many hits are present i.e., length of converted
    hits = 0
    for zap_alert in zap_report:
        for category, items in wapiti_report["vulnerabilities"].items():
            if len(category) <= 0:
                continue
            if zap_alert["alert"] == category: # TODO: if wapiti has more than 1 vulnerability in this category, check if the path matches else there is something needed to be done
                zap_url = urllib.parse.urlparse(zap_alert["url"])
                print(f"ZAP URL: {zap_url.path} | Wapiti URL: {items[0]['path']}") # remove the magic 0 number and do proper checks
                if zap_url.path == items[0]["path"]:
                    hits += 1
    print(f"Hits: {hits}")

find_matching()