# TODO: Compare results from wapiti and zap using Exploitability, Severity, Confidence, and Business Criticality (optional).
# TODO: Based on research, a unified report is better for overall practicality, while a deduplicated report is better for precision
# note: Template or conversions can be ENUMS
import json
import urllib.parse
from modules.utils.load_configs import DEV_ZAP_MAPPING

# TODO: function does not error, provide safety and error checks
# TODO: test function performance
def find_matching():
    zap_report = json.load(open("../../temp/zap/zap_test.json"))
    wapiti_report = json.load(open("../../reports/wapiti_test.json"))

    # convert zap findings to wapiti equivalent
    #TODO: Put what the research paper's algo here with two lists: union and intersection lists
    converted_report = convert_to_mapping(zap_report)
    _report, _converted,_residue = converted_report[0], converted_report[1], converted_report[2]

    #TODO: check if the respective alerts found the vulnerability on the same path
    #might be redundant since the template already checks how many hits are present i.e., length of converted
    hits = 0
    for zap_alert in zap_report:
        for category, items in wapiti_report["vulnerabilities"].items():
            if len(category) <= 0:
                continue
            if zap_alert["alert"] == category: # TODO: if wapiti has more than 1 vulnerability in this category, check if the path matches else there is something needed to be done
                zap_url = urllib.parse.urlparse(zap_alert["url"])
                print(f"ZAP URL: {zap_url.path} | Wapiti URL: {items[0]['path']}") # remove the magic 0 number and do proper checks
                if zap_url.path == items[0]["path"]:
                    hits += 1
    print(f"Hits: {hits}")

def convert_to_mapping(report: dict) -> list:
    """Converts a non-standard report into a standard one. The indexes are as follows: [0] for the report and [1] for the converted vulnerabilities.
    :arg report: The report to convert.
    :returns: A list that contains the converted report, converted vulnerabilities, and untouched vulnerabilities."""
    converted = []
    residue = []
    for alert in report: # loop is n + (n * 18) + n * 2 | 18 = length of template items | this is the worse-case
        if alert["risk"] == "Informational":
            continue
        is_residue = True
        for key,value in DEV_ZAP_MAPPING.items(): # A Hashmap or list of enums should perform faster?
            if isinstance(value, dict): #Clickjacking has two entries
                for entry in value.keys():
                    if alert["alert"] == entry:
                        alert["alert"] = key
                        converted.append(alert["alert"])
                        is_residue = False
                        break
            if alert["alert"] == value:
                alert["alert"] = key
                converted.append(alert["alert"])
                is_residue = False
        if is_residue:
            residue.append(alert["alert"])
    return [report, converted, residue]

find_matching()